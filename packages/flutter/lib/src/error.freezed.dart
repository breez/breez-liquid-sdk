// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LiquidSdkError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyStarted,
    required TResult Function(String err) generic,
    required TResult Function() notStarted,
    required TResult Function(String err) serviceConnectivity,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyStarted,
    TResult? Function(String err)? generic,
    TResult? Function()? notStarted,
    TResult? Function(String err)? serviceConnectivity,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyStarted,
    TResult Function(String err)? generic,
    TResult Function()? notStarted,
    TResult Function(String err)? serviceConnectivity,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiquidSdkError_AlreadyStarted value) alreadyStarted,
    required TResult Function(LiquidSdkError_Generic value) generic,
    required TResult Function(LiquidSdkError_NotStarted value) notStarted,
    required TResult Function(LiquidSdkError_ServiceConnectivity value) serviceConnectivity,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult? Function(LiquidSdkError_Generic value)? generic,
    TResult? Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult? Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult Function(LiquidSdkError_Generic value)? generic,
    TResult Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LiquidSdkErrorCopyWith<$Res> {
  factory $LiquidSdkErrorCopyWith(LiquidSdkError value, $Res Function(LiquidSdkError) then) =
      _$LiquidSdkErrorCopyWithImpl<$Res, LiquidSdkError>;
}

/// @nodoc
class _$LiquidSdkErrorCopyWithImpl<$Res, $Val extends LiquidSdkError>
    implements $LiquidSdkErrorCopyWith<$Res> {
  _$LiquidSdkErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LiquidSdkError_AlreadyStartedImplCopyWith<$Res> {
  factory _$$LiquidSdkError_AlreadyStartedImplCopyWith(_$LiquidSdkError_AlreadyStartedImpl value,
          $Res Function(_$LiquidSdkError_AlreadyStartedImpl) then) =
      __$$LiquidSdkError_AlreadyStartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LiquidSdkError_AlreadyStartedImplCopyWithImpl<$Res>
    extends _$LiquidSdkErrorCopyWithImpl<$Res, _$LiquidSdkError_AlreadyStartedImpl>
    implements _$$LiquidSdkError_AlreadyStartedImplCopyWith<$Res> {
  __$$LiquidSdkError_AlreadyStartedImplCopyWithImpl(
      _$LiquidSdkError_AlreadyStartedImpl _value, $Res Function(_$LiquidSdkError_AlreadyStartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LiquidSdkError_AlreadyStartedImpl extends LiquidSdkError_AlreadyStarted {
  const _$LiquidSdkError_AlreadyStartedImpl() : super._();

  @override
  String toString() {
    return 'LiquidSdkError.alreadyStarted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LiquidSdkError_AlreadyStartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyStarted,
    required TResult Function(String err) generic,
    required TResult Function() notStarted,
    required TResult Function(String err) serviceConnectivity,
  }) {
    return alreadyStarted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyStarted,
    TResult? Function(String err)? generic,
    TResult? Function()? notStarted,
    TResult? Function(String err)? serviceConnectivity,
  }) {
    return alreadyStarted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyStarted,
    TResult Function(String err)? generic,
    TResult Function()? notStarted,
    TResult Function(String err)? serviceConnectivity,
    required TResult orElse(),
  }) {
    if (alreadyStarted != null) {
      return alreadyStarted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiquidSdkError_AlreadyStarted value) alreadyStarted,
    required TResult Function(LiquidSdkError_Generic value) generic,
    required TResult Function(LiquidSdkError_NotStarted value) notStarted,
    required TResult Function(LiquidSdkError_ServiceConnectivity value) serviceConnectivity,
  }) {
    return alreadyStarted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult? Function(LiquidSdkError_Generic value)? generic,
    TResult? Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult? Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
  }) {
    return alreadyStarted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult Function(LiquidSdkError_Generic value)? generic,
    TResult Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
    required TResult orElse(),
  }) {
    if (alreadyStarted != null) {
      return alreadyStarted(this);
    }
    return orElse();
  }
}

abstract class LiquidSdkError_AlreadyStarted extends LiquidSdkError {
  const factory LiquidSdkError_AlreadyStarted() = _$LiquidSdkError_AlreadyStartedImpl;
  const LiquidSdkError_AlreadyStarted._() : super._();
}

/// @nodoc
abstract class _$$LiquidSdkError_GenericImplCopyWith<$Res> {
  factory _$$LiquidSdkError_GenericImplCopyWith(
          _$LiquidSdkError_GenericImpl value, $Res Function(_$LiquidSdkError_GenericImpl) then) =
      __$$LiquidSdkError_GenericImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$LiquidSdkError_GenericImplCopyWithImpl<$Res>
    extends _$LiquidSdkErrorCopyWithImpl<$Res, _$LiquidSdkError_GenericImpl>
    implements _$$LiquidSdkError_GenericImplCopyWith<$Res> {
  __$$LiquidSdkError_GenericImplCopyWithImpl(
      _$LiquidSdkError_GenericImpl _value, $Res Function(_$LiquidSdkError_GenericImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$LiquidSdkError_GenericImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LiquidSdkError_GenericImpl extends LiquidSdkError_Generic {
  const _$LiquidSdkError_GenericImpl({required this.err}) : super._();

  @override
  final String err;

  @override
  String toString() {
    return 'LiquidSdkError.generic(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiquidSdkError_GenericImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiquidSdkError_GenericImplCopyWith<_$LiquidSdkError_GenericImpl> get copyWith =>
      __$$LiquidSdkError_GenericImplCopyWithImpl<_$LiquidSdkError_GenericImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyStarted,
    required TResult Function(String err) generic,
    required TResult Function() notStarted,
    required TResult Function(String err) serviceConnectivity,
  }) {
    return generic(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyStarted,
    TResult? Function(String err)? generic,
    TResult? Function()? notStarted,
    TResult? Function(String err)? serviceConnectivity,
  }) {
    return generic?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyStarted,
    TResult Function(String err)? generic,
    TResult Function()? notStarted,
    TResult Function(String err)? serviceConnectivity,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiquidSdkError_AlreadyStarted value) alreadyStarted,
    required TResult Function(LiquidSdkError_Generic value) generic,
    required TResult Function(LiquidSdkError_NotStarted value) notStarted,
    required TResult Function(LiquidSdkError_ServiceConnectivity value) serviceConnectivity,
  }) {
    return generic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult? Function(LiquidSdkError_Generic value)? generic,
    TResult? Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult? Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
  }) {
    return generic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult Function(LiquidSdkError_Generic value)? generic,
    TResult Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(this);
    }
    return orElse();
  }
}

abstract class LiquidSdkError_Generic extends LiquidSdkError {
  const factory LiquidSdkError_Generic({required final String err}) = _$LiquidSdkError_GenericImpl;
  const LiquidSdkError_Generic._() : super._();

  String get err;
  @JsonKey(ignore: true)
  _$$LiquidSdkError_GenericImplCopyWith<_$LiquidSdkError_GenericImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiquidSdkError_NotStartedImplCopyWith<$Res> {
  factory _$$LiquidSdkError_NotStartedImplCopyWith(
          _$LiquidSdkError_NotStartedImpl value, $Res Function(_$LiquidSdkError_NotStartedImpl) then) =
      __$$LiquidSdkError_NotStartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LiquidSdkError_NotStartedImplCopyWithImpl<$Res>
    extends _$LiquidSdkErrorCopyWithImpl<$Res, _$LiquidSdkError_NotStartedImpl>
    implements _$$LiquidSdkError_NotStartedImplCopyWith<$Res> {
  __$$LiquidSdkError_NotStartedImplCopyWithImpl(
      _$LiquidSdkError_NotStartedImpl _value, $Res Function(_$LiquidSdkError_NotStartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LiquidSdkError_NotStartedImpl extends LiquidSdkError_NotStarted {
  const _$LiquidSdkError_NotStartedImpl() : super._();

  @override
  String toString() {
    return 'LiquidSdkError.notStarted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LiquidSdkError_NotStartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyStarted,
    required TResult Function(String err) generic,
    required TResult Function() notStarted,
    required TResult Function(String err) serviceConnectivity,
  }) {
    return notStarted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyStarted,
    TResult? Function(String err)? generic,
    TResult? Function()? notStarted,
    TResult? Function(String err)? serviceConnectivity,
  }) {
    return notStarted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyStarted,
    TResult Function(String err)? generic,
    TResult Function()? notStarted,
    TResult Function(String err)? serviceConnectivity,
    required TResult orElse(),
  }) {
    if (notStarted != null) {
      return notStarted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiquidSdkError_AlreadyStarted value) alreadyStarted,
    required TResult Function(LiquidSdkError_Generic value) generic,
    required TResult Function(LiquidSdkError_NotStarted value) notStarted,
    required TResult Function(LiquidSdkError_ServiceConnectivity value) serviceConnectivity,
  }) {
    return notStarted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult? Function(LiquidSdkError_Generic value)? generic,
    TResult? Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult? Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
  }) {
    return notStarted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult Function(LiquidSdkError_Generic value)? generic,
    TResult Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
    required TResult orElse(),
  }) {
    if (notStarted != null) {
      return notStarted(this);
    }
    return orElse();
  }
}

abstract class LiquidSdkError_NotStarted extends LiquidSdkError {
  const factory LiquidSdkError_NotStarted() = _$LiquidSdkError_NotStartedImpl;
  const LiquidSdkError_NotStarted._() : super._();
}

/// @nodoc
abstract class _$$LiquidSdkError_ServiceConnectivityImplCopyWith<$Res> {
  factory _$$LiquidSdkError_ServiceConnectivityImplCopyWith(_$LiquidSdkError_ServiceConnectivityImpl value,
          $Res Function(_$LiquidSdkError_ServiceConnectivityImpl) then) =
      __$$LiquidSdkError_ServiceConnectivityImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$LiquidSdkError_ServiceConnectivityImplCopyWithImpl<$Res>
    extends _$LiquidSdkErrorCopyWithImpl<$Res, _$LiquidSdkError_ServiceConnectivityImpl>
    implements _$$LiquidSdkError_ServiceConnectivityImplCopyWith<$Res> {
  __$$LiquidSdkError_ServiceConnectivityImplCopyWithImpl(_$LiquidSdkError_ServiceConnectivityImpl _value,
      $Res Function(_$LiquidSdkError_ServiceConnectivityImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$LiquidSdkError_ServiceConnectivityImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LiquidSdkError_ServiceConnectivityImpl extends LiquidSdkError_ServiceConnectivity {
  const _$LiquidSdkError_ServiceConnectivityImpl({required this.err}) : super._();

  @override
  final String err;

  @override
  String toString() {
    return 'LiquidSdkError.serviceConnectivity(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiquidSdkError_ServiceConnectivityImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiquidSdkError_ServiceConnectivityImplCopyWith<_$LiquidSdkError_ServiceConnectivityImpl> get copyWith =>
      __$$LiquidSdkError_ServiceConnectivityImplCopyWithImpl<_$LiquidSdkError_ServiceConnectivityImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyStarted,
    required TResult Function(String err) generic,
    required TResult Function() notStarted,
    required TResult Function(String err) serviceConnectivity,
  }) {
    return serviceConnectivity(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyStarted,
    TResult? Function(String err)? generic,
    TResult? Function()? notStarted,
    TResult? Function(String err)? serviceConnectivity,
  }) {
    return serviceConnectivity?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyStarted,
    TResult Function(String err)? generic,
    TResult Function()? notStarted,
    TResult Function(String err)? serviceConnectivity,
    required TResult orElse(),
  }) {
    if (serviceConnectivity != null) {
      return serviceConnectivity(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiquidSdkError_AlreadyStarted value) alreadyStarted,
    required TResult Function(LiquidSdkError_Generic value) generic,
    required TResult Function(LiquidSdkError_NotStarted value) notStarted,
    required TResult Function(LiquidSdkError_ServiceConnectivity value) serviceConnectivity,
  }) {
    return serviceConnectivity(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult? Function(LiquidSdkError_Generic value)? generic,
    TResult? Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult? Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
  }) {
    return serviceConnectivity?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiquidSdkError_AlreadyStarted value)? alreadyStarted,
    TResult Function(LiquidSdkError_Generic value)? generic,
    TResult Function(LiquidSdkError_NotStarted value)? notStarted,
    TResult Function(LiquidSdkError_ServiceConnectivity value)? serviceConnectivity,
    required TResult orElse(),
  }) {
    if (serviceConnectivity != null) {
      return serviceConnectivity(this);
    }
    return orElse();
  }
}

abstract class LiquidSdkError_ServiceConnectivity extends LiquidSdkError {
  const factory LiquidSdkError_ServiceConnectivity({required final String err}) =
      _$LiquidSdkError_ServiceConnectivityImpl;
  const LiquidSdkError_ServiceConnectivity._() : super._();

  String get err;
  @JsonKey(ignore: true)
  _$$LiquidSdkError_ServiceConnectivityImplCopyWith<_$LiquidSdkError_ServiceConnectivityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PaymentError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentErrorCopyWith<$Res> {
  factory $PaymentErrorCopyWith(PaymentError value, $Res Function(PaymentError) then) =
      _$PaymentErrorCopyWithImpl<$Res, PaymentError>;
}

/// @nodoc
class _$PaymentErrorCopyWithImpl<$Res, $Val extends PaymentError> implements $PaymentErrorCopyWith<$Res> {
  _$PaymentErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PaymentError_AlreadyClaimedImplCopyWith<$Res> {
  factory _$$PaymentError_AlreadyClaimedImplCopyWith(
          _$PaymentError_AlreadyClaimedImpl value, $Res Function(_$PaymentError_AlreadyClaimedImpl) then) =
      __$$PaymentError_AlreadyClaimedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_AlreadyClaimedImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_AlreadyClaimedImpl>
    implements _$$PaymentError_AlreadyClaimedImplCopyWith<$Res> {
  __$$PaymentError_AlreadyClaimedImplCopyWithImpl(
      _$PaymentError_AlreadyClaimedImpl _value, $Res Function(_$PaymentError_AlreadyClaimedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_AlreadyClaimedImpl extends PaymentError_AlreadyClaimed {
  const _$PaymentError_AlreadyClaimedImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.alreadyClaimed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_AlreadyClaimedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return alreadyClaimed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return alreadyClaimed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (alreadyClaimed != null) {
      return alreadyClaimed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return alreadyClaimed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return alreadyClaimed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (alreadyClaimed != null) {
      return alreadyClaimed(this);
    }
    return orElse();
  }
}

abstract class PaymentError_AlreadyClaimed extends PaymentError {
  const factory PaymentError_AlreadyClaimed() = _$PaymentError_AlreadyClaimedImpl;
  const PaymentError_AlreadyClaimed._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_AlreadyPaidImplCopyWith<$Res> {
  factory _$$PaymentError_AlreadyPaidImplCopyWith(
          _$PaymentError_AlreadyPaidImpl value, $Res Function(_$PaymentError_AlreadyPaidImpl) then) =
      __$$PaymentError_AlreadyPaidImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_AlreadyPaidImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_AlreadyPaidImpl>
    implements _$$PaymentError_AlreadyPaidImplCopyWith<$Res> {
  __$$PaymentError_AlreadyPaidImplCopyWithImpl(
      _$PaymentError_AlreadyPaidImpl _value, $Res Function(_$PaymentError_AlreadyPaidImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_AlreadyPaidImpl extends PaymentError_AlreadyPaid {
  const _$PaymentError_AlreadyPaidImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.alreadyPaid()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_AlreadyPaidImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return alreadyPaid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return alreadyPaid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (alreadyPaid != null) {
      return alreadyPaid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return alreadyPaid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return alreadyPaid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (alreadyPaid != null) {
      return alreadyPaid(this);
    }
    return orElse();
  }
}

abstract class PaymentError_AlreadyPaid extends PaymentError {
  const factory PaymentError_AlreadyPaid() = _$PaymentError_AlreadyPaidImpl;
  const PaymentError_AlreadyPaid._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_PaymentInProgressImplCopyWith<$Res> {
  factory _$$PaymentError_PaymentInProgressImplCopyWith(_$PaymentError_PaymentInProgressImpl value,
          $Res Function(_$PaymentError_PaymentInProgressImpl) then) =
      __$$PaymentError_PaymentInProgressImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_PaymentInProgressImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_PaymentInProgressImpl>
    implements _$$PaymentError_PaymentInProgressImplCopyWith<$Res> {
  __$$PaymentError_PaymentInProgressImplCopyWithImpl(
      _$PaymentError_PaymentInProgressImpl _value, $Res Function(_$PaymentError_PaymentInProgressImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_PaymentInProgressImpl extends PaymentError_PaymentInProgress {
  const _$PaymentError_PaymentInProgressImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.paymentInProgress()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_PaymentInProgressImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return paymentInProgress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return paymentInProgress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (paymentInProgress != null) {
      return paymentInProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return paymentInProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return paymentInProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (paymentInProgress != null) {
      return paymentInProgress(this);
    }
    return orElse();
  }
}

abstract class PaymentError_PaymentInProgress extends PaymentError {
  const factory PaymentError_PaymentInProgress() = _$PaymentError_PaymentInProgressImpl;
  const PaymentError_PaymentInProgress._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_AmountOutOfRangeImplCopyWith<$Res> {
  factory _$$PaymentError_AmountOutOfRangeImplCopyWith(_$PaymentError_AmountOutOfRangeImpl value,
          $Res Function(_$PaymentError_AmountOutOfRangeImpl) then) =
      __$$PaymentError_AmountOutOfRangeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_AmountOutOfRangeImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_AmountOutOfRangeImpl>
    implements _$$PaymentError_AmountOutOfRangeImplCopyWith<$Res> {
  __$$PaymentError_AmountOutOfRangeImplCopyWithImpl(
      _$PaymentError_AmountOutOfRangeImpl _value, $Res Function(_$PaymentError_AmountOutOfRangeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_AmountOutOfRangeImpl extends PaymentError_AmountOutOfRange {
  const _$PaymentError_AmountOutOfRangeImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.amountOutOfRange()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_AmountOutOfRangeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return amountOutOfRange();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return amountOutOfRange?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (amountOutOfRange != null) {
      return amountOutOfRange();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return amountOutOfRange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return amountOutOfRange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (amountOutOfRange != null) {
      return amountOutOfRange(this);
    }
    return orElse();
  }
}

abstract class PaymentError_AmountOutOfRange extends PaymentError {
  const factory PaymentError_AmountOutOfRange() = _$PaymentError_AmountOutOfRangeImpl;
  const PaymentError_AmountOutOfRange._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_GenericImplCopyWith<$Res> {
  factory _$$PaymentError_GenericImplCopyWith(
          _$PaymentError_GenericImpl value, $Res Function(_$PaymentError_GenericImpl) then) =
      __$$PaymentError_GenericImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$PaymentError_GenericImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_GenericImpl>
    implements _$$PaymentError_GenericImplCopyWith<$Res> {
  __$$PaymentError_GenericImplCopyWithImpl(
      _$PaymentError_GenericImpl _value, $Res Function(_$PaymentError_GenericImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$PaymentError_GenericImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentError_GenericImpl extends PaymentError_Generic {
  const _$PaymentError_GenericImpl({required this.err}) : super._();

  @override
  final String err;

  @override
  String toString() {
    return 'PaymentError.generic(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentError_GenericImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentError_GenericImplCopyWith<_$PaymentError_GenericImpl> get copyWith =>
      __$$PaymentError_GenericImplCopyWithImpl<_$PaymentError_GenericImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return generic(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return generic?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return generic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return generic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(this);
    }
    return orElse();
  }
}

abstract class PaymentError_Generic extends PaymentError {
  const factory PaymentError_Generic({required final String err}) = _$PaymentError_GenericImpl;
  const PaymentError_Generic._() : super._();

  String get err;
  @JsonKey(ignore: true)
  _$$PaymentError_GenericImplCopyWith<_$PaymentError_GenericImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentError_InvalidOrExpiredFeesImplCopyWith<$Res> {
  factory _$$PaymentError_InvalidOrExpiredFeesImplCopyWith(_$PaymentError_InvalidOrExpiredFeesImpl value,
          $Res Function(_$PaymentError_InvalidOrExpiredFeesImpl) then) =
      __$$PaymentError_InvalidOrExpiredFeesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_InvalidOrExpiredFeesImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_InvalidOrExpiredFeesImpl>
    implements _$$PaymentError_InvalidOrExpiredFeesImplCopyWith<$Res> {
  __$$PaymentError_InvalidOrExpiredFeesImplCopyWithImpl(_$PaymentError_InvalidOrExpiredFeesImpl _value,
      $Res Function(_$PaymentError_InvalidOrExpiredFeesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_InvalidOrExpiredFeesImpl extends PaymentError_InvalidOrExpiredFees {
  const _$PaymentError_InvalidOrExpiredFeesImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.invalidOrExpiredFees()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_InvalidOrExpiredFeesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return invalidOrExpiredFees();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return invalidOrExpiredFees?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (invalidOrExpiredFees != null) {
      return invalidOrExpiredFees();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return invalidOrExpiredFees(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return invalidOrExpiredFees?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (invalidOrExpiredFees != null) {
      return invalidOrExpiredFees(this);
    }
    return orElse();
  }
}

abstract class PaymentError_InvalidOrExpiredFees extends PaymentError {
  const factory PaymentError_InvalidOrExpiredFees() = _$PaymentError_InvalidOrExpiredFeesImpl;
  const PaymentError_InvalidOrExpiredFees._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_InsufficientFundsImplCopyWith<$Res> {
  factory _$$PaymentError_InsufficientFundsImplCopyWith(_$PaymentError_InsufficientFundsImpl value,
          $Res Function(_$PaymentError_InsufficientFundsImpl) then) =
      __$$PaymentError_InsufficientFundsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_InsufficientFundsImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_InsufficientFundsImpl>
    implements _$$PaymentError_InsufficientFundsImplCopyWith<$Res> {
  __$$PaymentError_InsufficientFundsImplCopyWithImpl(
      _$PaymentError_InsufficientFundsImpl _value, $Res Function(_$PaymentError_InsufficientFundsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_InsufficientFundsImpl extends PaymentError_InsufficientFunds {
  const _$PaymentError_InsufficientFundsImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.insufficientFunds()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_InsufficientFundsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return insufficientFunds();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return insufficientFunds?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return insufficientFunds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return insufficientFunds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(this);
    }
    return orElse();
  }
}

abstract class PaymentError_InsufficientFunds extends PaymentError {
  const factory PaymentError_InsufficientFunds() = _$PaymentError_InsufficientFundsImpl;
  const PaymentError_InsufficientFunds._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_InvalidInvoiceImplCopyWith<$Res> {
  factory _$$PaymentError_InvalidInvoiceImplCopyWith(
          _$PaymentError_InvalidInvoiceImpl value, $Res Function(_$PaymentError_InvalidInvoiceImpl) then) =
      __$$PaymentError_InvalidInvoiceImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$PaymentError_InvalidInvoiceImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_InvalidInvoiceImpl>
    implements _$$PaymentError_InvalidInvoiceImplCopyWith<$Res> {
  __$$PaymentError_InvalidInvoiceImplCopyWithImpl(
      _$PaymentError_InvalidInvoiceImpl _value, $Res Function(_$PaymentError_InvalidInvoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$PaymentError_InvalidInvoiceImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentError_InvalidInvoiceImpl extends PaymentError_InvalidInvoice {
  const _$PaymentError_InvalidInvoiceImpl({required this.err}) : super._();

  @override
  final String err;

  @override
  String toString() {
    return 'PaymentError.invalidInvoice(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentError_InvalidInvoiceImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentError_InvalidInvoiceImplCopyWith<_$PaymentError_InvalidInvoiceImpl> get copyWith =>
      __$$PaymentError_InvalidInvoiceImplCopyWithImpl<_$PaymentError_InvalidInvoiceImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return invalidInvoice(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return invalidInvoice?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (invalidInvoice != null) {
      return invalidInvoice(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return invalidInvoice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return invalidInvoice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (invalidInvoice != null) {
      return invalidInvoice(this);
    }
    return orElse();
  }
}

abstract class PaymentError_InvalidInvoice extends PaymentError {
  const factory PaymentError_InvalidInvoice({required final String err}) = _$PaymentError_InvalidInvoiceImpl;
  const PaymentError_InvalidInvoice._() : super._();

  String get err;
  @JsonKey(ignore: true)
  _$$PaymentError_InvalidInvoiceImplCopyWith<_$PaymentError_InvalidInvoiceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentError_InvalidPreimageImplCopyWith<$Res> {
  factory _$$PaymentError_InvalidPreimageImplCopyWith(
          _$PaymentError_InvalidPreimageImpl value, $Res Function(_$PaymentError_InvalidPreimageImpl) then) =
      __$$PaymentError_InvalidPreimageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_InvalidPreimageImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_InvalidPreimageImpl>
    implements _$$PaymentError_InvalidPreimageImplCopyWith<$Res> {
  __$$PaymentError_InvalidPreimageImplCopyWithImpl(
      _$PaymentError_InvalidPreimageImpl _value, $Res Function(_$PaymentError_InvalidPreimageImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_InvalidPreimageImpl extends PaymentError_InvalidPreimage {
  const _$PaymentError_InvalidPreimageImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.invalidPreimage()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_InvalidPreimageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return invalidPreimage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return invalidPreimage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (invalidPreimage != null) {
      return invalidPreimage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return invalidPreimage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return invalidPreimage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (invalidPreimage != null) {
      return invalidPreimage(this);
    }
    return orElse();
  }
}

abstract class PaymentError_InvalidPreimage extends PaymentError {
  const factory PaymentError_InvalidPreimage() = _$PaymentError_InvalidPreimageImpl;
  const PaymentError_InvalidPreimage._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_LwkErrorImplCopyWith<$Res> {
  factory _$$PaymentError_LwkErrorImplCopyWith(
          _$PaymentError_LwkErrorImpl value, $Res Function(_$PaymentError_LwkErrorImpl) then) =
      __$$PaymentError_LwkErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$PaymentError_LwkErrorImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_LwkErrorImpl>
    implements _$$PaymentError_LwkErrorImplCopyWith<$Res> {
  __$$PaymentError_LwkErrorImplCopyWithImpl(
      _$PaymentError_LwkErrorImpl _value, $Res Function(_$PaymentError_LwkErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$PaymentError_LwkErrorImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentError_LwkErrorImpl extends PaymentError_LwkError {
  const _$PaymentError_LwkErrorImpl({required this.err}) : super._();

  @override
  final String err;

  @override
  String toString() {
    return 'PaymentError.lwkError(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentError_LwkErrorImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentError_LwkErrorImplCopyWith<_$PaymentError_LwkErrorImpl> get copyWith =>
      __$$PaymentError_LwkErrorImplCopyWithImpl<_$PaymentError_LwkErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return lwkError(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return lwkError?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (lwkError != null) {
      return lwkError(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return lwkError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return lwkError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (lwkError != null) {
      return lwkError(this);
    }
    return orElse();
  }
}

abstract class PaymentError_LwkError extends PaymentError {
  const factory PaymentError_LwkError({required final String err}) = _$PaymentError_LwkErrorImpl;
  const PaymentError_LwkError._() : super._();

  String get err;
  @JsonKey(ignore: true)
  _$$PaymentError_LwkErrorImplCopyWith<_$PaymentError_LwkErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentError_PairsNotFoundImplCopyWith<$Res> {
  factory _$$PaymentError_PairsNotFoundImplCopyWith(
          _$PaymentError_PairsNotFoundImpl value, $Res Function(_$PaymentError_PairsNotFoundImpl) then) =
      __$$PaymentError_PairsNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_PairsNotFoundImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_PairsNotFoundImpl>
    implements _$$PaymentError_PairsNotFoundImplCopyWith<$Res> {
  __$$PaymentError_PairsNotFoundImplCopyWithImpl(
      _$PaymentError_PairsNotFoundImpl _value, $Res Function(_$PaymentError_PairsNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_PairsNotFoundImpl extends PaymentError_PairsNotFound {
  const _$PaymentError_PairsNotFoundImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.pairsNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_PairsNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return pairsNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return pairsNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (pairsNotFound != null) {
      return pairsNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return pairsNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return pairsNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (pairsNotFound != null) {
      return pairsNotFound(this);
    }
    return orElse();
  }
}

abstract class PaymentError_PairsNotFound extends PaymentError {
  const factory PaymentError_PairsNotFound() = _$PaymentError_PairsNotFoundImpl;
  const PaymentError_PairsNotFound._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_PaymentTimeoutImplCopyWith<$Res> {
  factory _$$PaymentError_PaymentTimeoutImplCopyWith(
          _$PaymentError_PaymentTimeoutImpl value, $Res Function(_$PaymentError_PaymentTimeoutImpl) then) =
      __$$PaymentError_PaymentTimeoutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_PaymentTimeoutImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_PaymentTimeoutImpl>
    implements _$$PaymentError_PaymentTimeoutImplCopyWith<$Res> {
  __$$PaymentError_PaymentTimeoutImplCopyWithImpl(
      _$PaymentError_PaymentTimeoutImpl _value, $Res Function(_$PaymentError_PaymentTimeoutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_PaymentTimeoutImpl extends PaymentError_PaymentTimeout {
  const _$PaymentError_PaymentTimeoutImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.paymentTimeout()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_PaymentTimeoutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return paymentTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return paymentTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (paymentTimeout != null) {
      return paymentTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return paymentTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return paymentTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (paymentTimeout != null) {
      return paymentTimeout(this);
    }
    return orElse();
  }
}

abstract class PaymentError_PaymentTimeout extends PaymentError {
  const factory PaymentError_PaymentTimeout() = _$PaymentError_PaymentTimeoutImpl;
  const PaymentError_PaymentTimeout._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_PersistErrorImplCopyWith<$Res> {
  factory _$$PaymentError_PersistErrorImplCopyWith(
          _$PaymentError_PersistErrorImpl value, $Res Function(_$PaymentError_PersistErrorImpl) then) =
      __$$PaymentError_PersistErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_PersistErrorImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_PersistErrorImpl>
    implements _$$PaymentError_PersistErrorImplCopyWith<$Res> {
  __$$PaymentError_PersistErrorImplCopyWithImpl(
      _$PaymentError_PersistErrorImpl _value, $Res Function(_$PaymentError_PersistErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_PersistErrorImpl extends PaymentError_PersistError {
  const _$PaymentError_PersistErrorImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.persistError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_PersistErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return persistError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return persistError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (persistError != null) {
      return persistError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return persistError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return persistError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (persistError != null) {
      return persistError(this);
    }
    return orElse();
  }
}

abstract class PaymentError_PersistError extends PaymentError {
  const factory PaymentError_PersistError() = _$PaymentError_PersistErrorImpl;
  const PaymentError_PersistError._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_ReceiveErrorImplCopyWith<$Res> {
  factory _$$PaymentError_ReceiveErrorImplCopyWith(
          _$PaymentError_ReceiveErrorImpl value, $Res Function(_$PaymentError_ReceiveErrorImpl) then) =
      __$$PaymentError_ReceiveErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$PaymentError_ReceiveErrorImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_ReceiveErrorImpl>
    implements _$$PaymentError_ReceiveErrorImplCopyWith<$Res> {
  __$$PaymentError_ReceiveErrorImplCopyWithImpl(
      _$PaymentError_ReceiveErrorImpl _value, $Res Function(_$PaymentError_ReceiveErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$PaymentError_ReceiveErrorImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentError_ReceiveErrorImpl extends PaymentError_ReceiveError {
  const _$PaymentError_ReceiveErrorImpl({required this.err}) : super._();

  @override
  final String err;

  @override
  String toString() {
    return 'PaymentError.receiveError(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentError_ReceiveErrorImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentError_ReceiveErrorImplCopyWith<_$PaymentError_ReceiveErrorImpl> get copyWith =>
      __$$PaymentError_ReceiveErrorImplCopyWithImpl<_$PaymentError_ReceiveErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return receiveError(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return receiveError?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (receiveError != null) {
      return receiveError(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return receiveError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return receiveError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (receiveError != null) {
      return receiveError(this);
    }
    return orElse();
  }
}

abstract class PaymentError_ReceiveError extends PaymentError {
  const factory PaymentError_ReceiveError({required final String err}) = _$PaymentError_ReceiveErrorImpl;
  const PaymentError_ReceiveError._() : super._();

  String get err;
  @JsonKey(ignore: true)
  _$$PaymentError_ReceiveErrorImplCopyWith<_$PaymentError_ReceiveErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentError_RefundedImplCopyWith<$Res> {
  factory _$$PaymentError_RefundedImplCopyWith(
          _$PaymentError_RefundedImpl value, $Res Function(_$PaymentError_RefundedImpl) then) =
      __$$PaymentError_RefundedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err, String refundTxId});
}

/// @nodoc
class __$$PaymentError_RefundedImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_RefundedImpl>
    implements _$$PaymentError_RefundedImplCopyWith<$Res> {
  __$$PaymentError_RefundedImplCopyWithImpl(
      _$PaymentError_RefundedImpl _value, $Res Function(_$PaymentError_RefundedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
    Object? refundTxId = null,
  }) {
    return _then(_$PaymentError_RefundedImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
      refundTxId: null == refundTxId
          ? _value.refundTxId
          : refundTxId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentError_RefundedImpl extends PaymentError_Refunded {
  const _$PaymentError_RefundedImpl({required this.err, required this.refundTxId}) : super._();

  @override
  final String err;
  @override
  final String refundTxId;

  @override
  String toString() {
    return 'PaymentError.refunded(err: $err, refundTxId: $refundTxId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentError_RefundedImpl &&
            (identical(other.err, err) || other.err == err) &&
            (identical(other.refundTxId, refundTxId) || other.refundTxId == refundTxId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err, refundTxId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentError_RefundedImplCopyWith<_$PaymentError_RefundedImpl> get copyWith =>
      __$$PaymentError_RefundedImplCopyWithImpl<_$PaymentError_RefundedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return refunded(err, refundTxId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return refunded?.call(err, refundTxId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (refunded != null) {
      return refunded(err, refundTxId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return refunded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return refunded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (refunded != null) {
      return refunded(this);
    }
    return orElse();
  }
}

abstract class PaymentError_Refunded extends PaymentError {
  const factory PaymentError_Refunded({required final String err, required final String refundTxId}) =
      _$PaymentError_RefundedImpl;
  const PaymentError_Refunded._() : super._();

  String get err;
  String get refundTxId;
  @JsonKey(ignore: true)
  _$$PaymentError_RefundedImplCopyWith<_$PaymentError_RefundedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentError_SelfTransferNotSupportedImplCopyWith<$Res> {
  factory _$$PaymentError_SelfTransferNotSupportedImplCopyWith(
          _$PaymentError_SelfTransferNotSupportedImpl value,
          $Res Function(_$PaymentError_SelfTransferNotSupportedImpl) then) =
      __$$PaymentError_SelfTransferNotSupportedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentError_SelfTransferNotSupportedImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_SelfTransferNotSupportedImpl>
    implements _$$PaymentError_SelfTransferNotSupportedImplCopyWith<$Res> {
  __$$PaymentError_SelfTransferNotSupportedImplCopyWithImpl(
      _$PaymentError_SelfTransferNotSupportedImpl _value,
      $Res Function(_$PaymentError_SelfTransferNotSupportedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentError_SelfTransferNotSupportedImpl extends PaymentError_SelfTransferNotSupported {
  const _$PaymentError_SelfTransferNotSupportedImpl() : super._();

  @override
  String toString() {
    return 'PaymentError.selfTransferNotSupported()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentError_SelfTransferNotSupportedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return selfTransferNotSupported();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return selfTransferNotSupported?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (selfTransferNotSupported != null) {
      return selfTransferNotSupported();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return selfTransferNotSupported(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return selfTransferNotSupported?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (selfTransferNotSupported != null) {
      return selfTransferNotSupported(this);
    }
    return orElse();
  }
}

abstract class PaymentError_SelfTransferNotSupported extends PaymentError {
  const factory PaymentError_SelfTransferNotSupported() = _$PaymentError_SelfTransferNotSupportedImpl;
  const PaymentError_SelfTransferNotSupported._() : super._();
}

/// @nodoc
abstract class _$$PaymentError_SendErrorImplCopyWith<$Res> {
  factory _$$PaymentError_SendErrorImplCopyWith(
          _$PaymentError_SendErrorImpl value, $Res Function(_$PaymentError_SendErrorImpl) then) =
      __$$PaymentError_SendErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$PaymentError_SendErrorImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_SendErrorImpl>
    implements _$$PaymentError_SendErrorImplCopyWith<$Res> {
  __$$PaymentError_SendErrorImplCopyWithImpl(
      _$PaymentError_SendErrorImpl _value, $Res Function(_$PaymentError_SendErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$PaymentError_SendErrorImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentError_SendErrorImpl extends PaymentError_SendError {
  const _$PaymentError_SendErrorImpl({required this.err}) : super._();

  @override
  final String err;

  @override
  String toString() {
    return 'PaymentError.sendError(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentError_SendErrorImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentError_SendErrorImplCopyWith<_$PaymentError_SendErrorImpl> get copyWith =>
      __$$PaymentError_SendErrorImplCopyWithImpl<_$PaymentError_SendErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return sendError(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return sendError?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (sendError != null) {
      return sendError(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return sendError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return sendError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (sendError != null) {
      return sendError(this);
    }
    return orElse();
  }
}

abstract class PaymentError_SendError extends PaymentError {
  const factory PaymentError_SendError({required final String err}) = _$PaymentError_SendErrorImpl;
  const PaymentError_SendError._() : super._();

  String get err;
  @JsonKey(ignore: true)
  _$$PaymentError_SendErrorImplCopyWith<_$PaymentError_SendErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentError_SignerErrorImplCopyWith<$Res> {
  factory _$$PaymentError_SignerErrorImplCopyWith(
          _$PaymentError_SignerErrorImpl value, $Res Function(_$PaymentError_SignerErrorImpl) then) =
      __$$PaymentError_SignerErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$PaymentError_SignerErrorImplCopyWithImpl<$Res>
    extends _$PaymentErrorCopyWithImpl<$Res, _$PaymentError_SignerErrorImpl>
    implements _$$PaymentError_SignerErrorImplCopyWith<$Res> {
  __$$PaymentError_SignerErrorImplCopyWithImpl(
      _$PaymentError_SignerErrorImpl _value, $Res Function(_$PaymentError_SignerErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$PaymentError_SignerErrorImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentError_SignerErrorImpl extends PaymentError_SignerError {
  const _$PaymentError_SignerErrorImpl({required this.err}) : super._();

  @override
  final String err;

  @override
  String toString() {
    return 'PaymentError.signerError(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentError_SignerErrorImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentError_SignerErrorImplCopyWith<_$PaymentError_SignerErrorImpl> get copyWith =>
      __$$PaymentError_SignerErrorImplCopyWithImpl<_$PaymentError_SignerErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() alreadyClaimed,
    required TResult Function() alreadyPaid,
    required TResult Function() paymentInProgress,
    required TResult Function() amountOutOfRange,
    required TResult Function(String err) generic,
    required TResult Function() invalidOrExpiredFees,
    required TResult Function() insufficientFunds,
    required TResult Function(String err) invalidInvoice,
    required TResult Function() invalidPreimage,
    required TResult Function(String err) lwkError,
    required TResult Function() pairsNotFound,
    required TResult Function() paymentTimeout,
    required TResult Function() persistError,
    required TResult Function(String err) receiveError,
    required TResult Function(String err, String refundTxId) refunded,
    required TResult Function() selfTransferNotSupported,
    required TResult Function(String err) sendError,
    required TResult Function(String err) signerError,
  }) {
    return signerError(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? alreadyClaimed,
    TResult? Function()? alreadyPaid,
    TResult? Function()? paymentInProgress,
    TResult? Function()? amountOutOfRange,
    TResult? Function(String err)? generic,
    TResult? Function()? invalidOrExpiredFees,
    TResult? Function()? insufficientFunds,
    TResult? Function(String err)? invalidInvoice,
    TResult? Function()? invalidPreimage,
    TResult? Function(String err)? lwkError,
    TResult? Function()? pairsNotFound,
    TResult? Function()? paymentTimeout,
    TResult? Function()? persistError,
    TResult? Function(String err)? receiveError,
    TResult? Function(String err, String refundTxId)? refunded,
    TResult? Function()? selfTransferNotSupported,
    TResult? Function(String err)? sendError,
    TResult? Function(String err)? signerError,
  }) {
    return signerError?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? alreadyClaimed,
    TResult Function()? alreadyPaid,
    TResult Function()? paymentInProgress,
    TResult Function()? amountOutOfRange,
    TResult Function(String err)? generic,
    TResult Function()? invalidOrExpiredFees,
    TResult Function()? insufficientFunds,
    TResult Function(String err)? invalidInvoice,
    TResult Function()? invalidPreimage,
    TResult Function(String err)? lwkError,
    TResult Function()? pairsNotFound,
    TResult Function()? paymentTimeout,
    TResult Function()? persistError,
    TResult Function(String err)? receiveError,
    TResult Function(String err, String refundTxId)? refunded,
    TResult Function()? selfTransferNotSupported,
    TResult Function(String err)? sendError,
    TResult Function(String err)? signerError,
    required TResult orElse(),
  }) {
    if (signerError != null) {
      return signerError(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentError_AlreadyClaimed value) alreadyClaimed,
    required TResult Function(PaymentError_AlreadyPaid value) alreadyPaid,
    required TResult Function(PaymentError_PaymentInProgress value) paymentInProgress,
    required TResult Function(PaymentError_AmountOutOfRange value) amountOutOfRange,
    required TResult Function(PaymentError_Generic value) generic,
    required TResult Function(PaymentError_InvalidOrExpiredFees value) invalidOrExpiredFees,
    required TResult Function(PaymentError_InsufficientFunds value) insufficientFunds,
    required TResult Function(PaymentError_InvalidInvoice value) invalidInvoice,
    required TResult Function(PaymentError_InvalidPreimage value) invalidPreimage,
    required TResult Function(PaymentError_LwkError value) lwkError,
    required TResult Function(PaymentError_PairsNotFound value) pairsNotFound,
    required TResult Function(PaymentError_PaymentTimeout value) paymentTimeout,
    required TResult Function(PaymentError_PersistError value) persistError,
    required TResult Function(PaymentError_ReceiveError value) receiveError,
    required TResult Function(PaymentError_Refunded value) refunded,
    required TResult Function(PaymentError_SelfTransferNotSupported value) selfTransferNotSupported,
    required TResult Function(PaymentError_SendError value) sendError,
    required TResult Function(PaymentError_SignerError value) signerError,
  }) {
    return signerError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult? Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult? Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult? Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult? Function(PaymentError_Generic value)? generic,
    TResult? Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult? Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult? Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult? Function(PaymentError_LwkError value)? lwkError,
    TResult? Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult? Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult? Function(PaymentError_PersistError value)? persistError,
    TResult? Function(PaymentError_ReceiveError value)? receiveError,
    TResult? Function(PaymentError_Refunded value)? refunded,
    TResult? Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult? Function(PaymentError_SendError value)? sendError,
    TResult? Function(PaymentError_SignerError value)? signerError,
  }) {
    return signerError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentError_AlreadyClaimed value)? alreadyClaimed,
    TResult Function(PaymentError_AlreadyPaid value)? alreadyPaid,
    TResult Function(PaymentError_PaymentInProgress value)? paymentInProgress,
    TResult Function(PaymentError_AmountOutOfRange value)? amountOutOfRange,
    TResult Function(PaymentError_Generic value)? generic,
    TResult Function(PaymentError_InvalidOrExpiredFees value)? invalidOrExpiredFees,
    TResult Function(PaymentError_InsufficientFunds value)? insufficientFunds,
    TResult Function(PaymentError_InvalidInvoice value)? invalidInvoice,
    TResult Function(PaymentError_InvalidPreimage value)? invalidPreimage,
    TResult Function(PaymentError_LwkError value)? lwkError,
    TResult Function(PaymentError_PairsNotFound value)? pairsNotFound,
    TResult Function(PaymentError_PaymentTimeout value)? paymentTimeout,
    TResult Function(PaymentError_PersistError value)? persistError,
    TResult Function(PaymentError_ReceiveError value)? receiveError,
    TResult Function(PaymentError_Refunded value)? refunded,
    TResult Function(PaymentError_SelfTransferNotSupported value)? selfTransferNotSupported,
    TResult Function(PaymentError_SendError value)? sendError,
    TResult Function(PaymentError_SignerError value)? signerError,
    required TResult orElse(),
  }) {
    if (signerError != null) {
      return signerError(this);
    }
    return orElse();
  }
}

abstract class PaymentError_SignerError extends PaymentError {
  const factory PaymentError_SignerError({required final String err}) = _$PaymentError_SignerErrorImpl;
  const PaymentError_SignerError._() : super._();

  String get err;
  @JsonKey(ignore: true)
  _$$PaymentError_SignerErrorImplCopyWith<_$PaymentError_SignerErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
